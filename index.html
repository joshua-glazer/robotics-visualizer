<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Joshua Glazer" />
  <meta name="viewport" content="width=device-width">
  <title>Reference Frame Visualizations</title>
  <style>
    body {
      margin: 0;
    }
	canvas {
		width: 100%;
		height: 100%
	}
  </style>
</head>

<body>  
<div id="container"></div>
<script src="three.min.js"></script>
<script>
	
	/* setup */
	var near = 1;
	var far = 1000;
	var angleIncrement = 0.25
	
	var origin = new THREE.Vector3(0,0,0);
	var xAxis = new THREE.Vector3(1,0,0);
	var yAxis = new THREE.Vector3(0,1,0);
	var zAxis = new THREE.Vector3(0,0,1);
	
	var xColour = 0xff0000; 
	var yColour = 0x00ff00;
	var zColour = 0x0000ff;
	
	var desiredRoll = 30;
	var desiredPitch = 90;//0;
	var desiredYaw = 45;
	
	// for fixed axis rotations
	var isFixedAxis = true; var isEulerAngles = false;
	// for euler angle rotations
	//var isFixedAxis = false; var isEulerAngles = true;
	
	/* renderer */
	var renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	
	const container = document.querySelector('#container');
	container.appendChild(renderer.domElement);	
	
	/* scene */
	var scene = new THREE.Scene();
	
	/* camera */
	var camera = 
		new THREE.PerspectiveCamera(
			10,
			window.innerWidth / window.innerHeight,
			near,
			far
		);
	
	camera.up = zAxis;
	camera.position.set(10, 10, 10);
	camera.lookAt(scene.position);
	
	scene.add(camera);
	
	// resizes window automatically
	window.addEventListener( 'resize', 
		function () {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			//controls.handleResize();
		},
		false
	);
	
	/* frames */
	var baseFrame = new THREE.AxisHelper(0.5);
	var toolFrame = new THREE.AxisHelper(1);
	
	var baseX = new THREE.ArrowHelper(xAxis, origin, 0.5, xColour);
	var baseY = new THREE.ArrowHelper(yAxis, origin, 0.5, yColour);
	var baseZ = new THREE.ArrowHelper(zAxis, origin, 0.5, zColour);
	var toolX = new THREE.ArrowHelper(xAxis, origin, 1, xColour);
	var toolY = new THREE.ArrowHelper(yAxis, origin, 1, yColour);
	var toolZ = new THREE.ArrowHelper(zAxis, origin, 1, zColour);
	
	//scene.add(baseFrame);
	scene.add(toolFrame);
	scene.add(baseX); scene.add(baseY);	scene.add(baseZ);
	//scene.add(toolX); scene.add(toolY); scene.add(toolZ);
	
	/* functions */
	/*
	// from https://stackoverflow.com/questions/11119753/how-to-rotate-a-object-on-axis-world-three-js
	var rotWorldMatrix;
	// Rotate an object around an arbitrary axis in world space       
	function rotateAroundWorldAxis(object, axis, radians) {
		rotWorldMatrix = new THREE.Matrix4();
		rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
		//rotWorldMatrix.multiplySelf(object.matrix);        // pre-multiply
		rotWorldMatrix.multiply(object.matrix);        // pre-multiply
		object.matrix = rotWorldMatrix;
		//object.rotation.getRotationFromMatrix(object.matrix, object.scale);
		object.rotation.setFromRotationMatrix(object.matrix);
	}
	*/
	
	var i = 0; var j = 0; var k = 0;
	var rotationComplete = false;
	var xDone = false; var yDone = false; var zDone = false;
	
	// this means that rotating x then y then z works like fixed angles
	// and rotating z then y then x works like euler angles
	toolFrame.rotation.order = 'ZYX';
	toolX.rotation.order = 'ZYX'; toolY.rotation.order = 'ZYX'; toolZ.rotation.order = 'ZYX';
	
	// rotates about the base frame's axes
	function rotateFixedAxis(roll, pitch, yaw){
		if (i < roll) {
			i += angleIncrement;
			toolFrame.rotation.x += THREE.Math.degToRad(angleIncrement);
			//toolX.rotation.x += THREE.Math.degToRad(angleIncrement);
			//toolY.rotation.x += THREE.Math.degToRad(angleIncrement);
			//toolZ.rotation.x += THREE.Math.degToRad(angleIncrement);
		}
		else {
			xDone = true;
		}
		if (xDone) {
			if (j < pitch) {
				j += angleIncrement;
				toolFrame.rotation.y += THREE.Math.degToRad(angleIncrement);
				//toolX.rotation.y += THREE.Math.degToRad(angleIncrement);
				//toolY.rotation.y += THREE.Math.degToRad(angleIncrement);
				//toolZ.rotation.y += THREE.Math.degToRad(angleIncrement);
			}
			else {
				yDone = true;
			}
			if (yDone) {
				if (k < yaw) {
					k += angleIncrement;
					toolFrame.rotation.z += THREE.Math.degToRad(angleIncrement);
					//toolX.rotation.z += THREE.Math.degToRad(angleIncrement);
					//toolY.rotation.z += THREE.Math.degToRad(angleIncrement);
					//toolZ.rotation.z += THREE.Math.degToRad(angleIncrement);
				}
				else {
					zDone = true;
					rotationComplete = true;
				}
			}
		}
		/*
		// this code lets me perform rotations around the world axes regardles of rotation order
		if (i < roll) {
			i += angleIncrement
			rotateAroundWorldAxis(toolFrame, xAxis, THREE.Math.degToRad(angleIncrement));
		}
		else {
			xDone = true;
		}	
		if (xDone) {
			if (j < pitch) {
				k += angleIncrement
				rotateAroundWorldAxis(toolFrame, yAxis, THREE.Math.degToRad(angleIncrement));
			}
			else {
				yDone = true;
			}
			if (yDone){
				if (k < yaw) {
					k += angleIncrement
					rotateAroundWorldAxis(toolFrame, zAxis, THREE.Math.degToRad(angleIncrement));
				}
				else {
					zDone = true;
					rotationComplete = true;
				}
			}
		}
		*/
	}
	
	// rotates about the tool frame's own axes
	function rotateEulerAngles(roll, pitch, yaw){
		if (k < yaw) {
			k += angleIncrement;
			toolFrame.rotation.z += THREE.Math.degToRad(angleIncrement);
			//toolX.rotation.x += THREE.Math.degToRad(angleIncrement);
			//toolY.rotation.x += THREE.Math.degToRad(angleIncrement);
			//toolZ.rotation.x += THREE.Math.degToRad(angleIncrement);
		}
		else {
			zDone = true;
		}
		if (zDone) {
			if (j < pitch) {
				j += angleIncrement;
				toolFrame.rotation.y += THREE.Math.degToRad(angleIncrement);
				//toolX.rotation.y += THREE.Math.degToRad(angleIncrement);
				//toolY.rotation.y += THREE.Math.degToRad(angleIncrement);
				//toolZ.rotation.y += THREE.Math.degToRad(angleIncrement);
			}
			else {
				yDone = true;
			}
			if (yDone) {
				if (i < roll) {
					i += angleIncrement;
					toolFrame.rotation.x += THREE.Math.degToRad(angleIncrement);
					//toolX.rotation.z += THREE.Math.degToRad(angleIncrement);
					//toolY.rotation.z += THREE.Math.degToRad(angleIncrement);
					//toolZ.rotation.z += THREE.Math.degToRad(angleIncrement);
				}
				else {
					xDone = true;
					rotationComplete = true;
				}
			}
		}
	}
	
	/* this function and the following call cause an endless loop of rendering */
	function update() {
		if (!rotationComplete){
			if (isFixedAxis){
				rotateFixedAxis(desiredRoll, desiredPitch, desiredYaw);
			}
			else if (isEulerAngles){
				rotateEulerAngles(desiredRoll, desiredPitch, desiredYaw);
			}
		}
		renderer.render(scene, camera);
		requestAnimationFrame(update);
	}
	
	// this causes the scene to be rendered and then update() recursively calls itself
	requestAnimationFrame(update);
	
</script>
</body>

</html>