<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Joshua Glazer" />
  <meta name="viewport" content="width=device-width">
  <title>Reference Frame Visualizations</title>
  <style>
    body {
      margin: 0;
    }
	canvas {
		width: 100%;
		height: 100%
	}
  </style>
</head>

<body>  
<div id="container"></div>
<script src="three.min.js"></script>
<script>
	const NEAR = 1;
    const FAR = 1000;
	
	const container = document.querySelector('#container');
		
	var scene,
		camera,
		renderer,
		controls;
	
	scene = new THREE.Scene();
	
	camera = 
		new THREE.PerspectiveCamera(
			10,
			window.innerWidth / window.innerHeight,
			NEAR,
			FAR
		);
	
	camera.up.set(0, 0, 1);
	camera.position.set(10, 10, 10);
	camera.lookAt(scene.position);
	
	scene.add(camera);
	
	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	
	container.appendChild(renderer.domElement);	
	
	const pointLight =
      new THREE.PointLight(0xFFFFFF);

    pointLight.position.x = 10;
    pointLight.position.y = 50;
    pointLight.position.z = 130;

    scene.add(pointLight);

	var baseFrame = new THREE.AxisHelper(1);
	var toolFrame = new THREE.AxisHelper(1);
	
	scene.add(baseFrame);
	scene.add(toolFrame);
	
	/*
	// from https://stackoverflow.com/questions/11119753/how-to-rotate-a-object-on-axis-world-three-js
	var rotWorldMatrix;
	// Rotate an object around an arbitrary axis in world space       
	function rotateAroundWorldAxis(object, axis, radians) {
		rotWorldMatrix = new THREE.Matrix4();
		rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
		//rotWorldMatrix.multiplySelf(object.matrix);        // pre-multiply
		rotWorldMatrix.multiply(object.matrix);        // pre-multiply
		object.matrix = rotWorldMatrix;
		//object.rotation.getRotationFromMatrix(object.matrix, object.scale);
		object.rotation.setFromRotationMatrix(object.matrix);
	}
	*/
	
	var angleIncrement = 0.25
	var i = 0; var j = 0; var k = 0;
	var desiredRoll = 30; var desiredPitch = 0; var desiredYaw = 45;
	var xDone = false; var yDone = false; var zDone = false;
	
	// for fixed axis rotations
	var fixedAxis = true; var eulerAngles = false;
	// for euler angle rotations
	//var fixedAxis = false; var eulerAngles = true;
	
	// this means that rotating x then y then z works like fixed angles
	// and rotating z then y then x works like euler angles
	toolFrame.rotation.order = 'ZXY';
	
	function rotateFixedAxis(roll, pitch, yaw){
		if (i < roll) {
			i += angleIncrement;
			toolFrame.rotation.x += THREE.Math.degToRad(angleIncrement);
		}
		else {
			xDone = true;
		}
		if (xDone) {
			if (j < pitch) {
				j += angleIncrement;
				toolFrame.rotation.y += THREE.Math.degToRad(angleIncrement);
			}
			else {
				yDone = true;
			}
			if (yDone) {
				if (k < yaw) {
					k += angleIncrement;
					toolFrame.rotation.z += THREE.Math.degToRad(angleIncrement);
				}
				else {
					zDone = true;
				}
			}
		}
		/*
		// this code lets me perform rotations around the world axes regardles of rotation order
		var xAxis = new THREE.Vector3(1,0,0);
		var yAxis = new THREE.Vector3(0,1,0);
		var zAxis = new THREE.Vector3(0,0,1);
		if (i < roll) {
			i += angleIncrement
			rotateAroundWorldAxis(toolFrame, xAxis, THREE.Math.degToRad(angleIncrement));
		}
		else {
			xDone = true;
		}	
		if (xDone) {
			if (j < pitch) {
				k += angleIncrement
				rotateAroundWorldAxis(toolFrame, yAxis, THREE.Math.degToRad(angleIncrement));
			}
			else {
				yDone = true;
			}
			if (yDone){
				if (k < yaw) {
					k += angleIncrement
					rotateAroundWorldAxis(toolFrame, zAxis, THREE.Math.degToRad(angleIncrement));
				}
				else {
					zDone = true;
				}
			}
		}
		*/
	}
	
	function rotateEulerAngles(roll, pitch, yaw){
		if (k < yaw) {
			k += angleIncrement;
			toolFrame.rotation.z += THREE.Math.degToRad(angleIncrement);
		}
		else {
			zDone = true;
		}
		if (zDone) {
			if (j < pitch) {
				j += angleIncrement;
				toolFrame.rotation.y += THREE.Math.degToRad(angleIncrement);
			}
			else {
				yDone = true;
			}
			if (yDone) {
				if (i < roll) {
					i += angleIncrement;
					toolFrame.rotation.x += THREE.Math.degToRad(angleIncrement);
				}
				else {
					xDone = true;
				}
			}
		}
	}
	
	function update() {
		if (fixedAxis){
			rotateFixedAxis(desiredRoll, desiredPitch, desiredYaw);
		}
		else if (eulerAngles){
			rotateEulerAngles(desiredRoll, desiredPitch, desiredYaw);
		}

		renderer.render(scene, camera);
		requestAnimationFrame(update);
	}
	
	requestAnimationFrame(update);
	
	window.addEventListener( 'resize', 
		function () {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			//controls.handleResize();
		},
		false
	);
	
</script>
</body>

</html>